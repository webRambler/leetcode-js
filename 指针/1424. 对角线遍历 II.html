<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>1424. 对角线遍历 II</title>
</head>
<body>

<script>
  // 给你一个列表nums，里面每一个元素都是一个整数列表。请你依照下面各图的规则，按顺序返回nums中对角线上的整数。
  //
  // 示例 1：
  // 输入：nums = [[1,2,3],[4,5,6],[7,8,9]]
  // 输出：[1,4,2,7,5,3,8,6,9]
  //
  // 示例 2：
  // 输入：nums = [[1,2,3,4,5],[6,7],[8],[9,10,11],[12,13,14,15,16]]
  // 输出：[1,6,2,8,7,3,9,4,12,10,5,13,11,14,15,16]
  //
  // 示例 3：
  // 输入：nums = [[1,2,3],[4],[5,6,7],[8],[9,10,11]]
  // 输出：[1,4,2,5,3,8,6,9,7,10,11]
  //
  // 示例 4：
  // 输入：nums = [[1,2,3,4,5,6]]
  // 输出：[1,2,3,4,5,6]
  //
  //
  // 提示：
  // 1 <= nums.length <= 10^5
  // 1 <= nums[i].length <=10^5
  // 1 <= nums[i][j] <= 10^9
  // nums中最多有10^5个数字。

  // 解法一：双指针（对角线上的元素横纵坐标加起来之和相等，例如arr[2][0]、arr[1][1]、arr[0][2]此三个元素在一条对角线上）
  // 此方法超时（失败）
  /**
   * @param {number[][]} nums
   * @return {number[]}
   */
  var findDiagonalOrder = function(nums) {
    let n = nums.length
    nums.forEach(arr => {
      n = Math.max(n, arr.length)
    })
    const res = []
    for (let i = 0; i < 2 * n; i++) {
      let horizontal, vertical
      if (i < n) {
        horizontal = 0
        vertical = i
      } else {
        horizontal = i - n + 1
        vertical = n - 1
      }
      let pos = vertical
      while (horizontal <= pos) {
        if (nums[vertical] && nums[vertical][horizontal]) {
          res.push(nums[vertical][horizontal])
        }
        vertical--
        horizontal++
      }
    }
    return res
  };

  findDiagonalOrder([[1,2,3],[6,7,8],[9,10,11]])

</script>
</body>
</html>
